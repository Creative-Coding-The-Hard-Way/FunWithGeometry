mod composed_message;

use ::anyhow::Result;

pub use self::composed_message::{ComposedElement, ComposedMessage};
use crate::graphics::{
    immediate_mode_graphics::triangles::Frame,
    ui::{
        primitives::Dimensions,
        widgets::{AutoElement, Element, Widget},
        Id, Input, InternalState,
    },
    Vec2,
};

/// Types which implemnet this type can act like a stateful collection of
/// widges in the UI layout.
pub trait CompositeWidget<IMessage, EMessage> {
    /// The internal state used by this type. This is automatically retrieved
    /// from InternalStorage based on the id.
    type State;

    /// This instance's Id. For predictable behavior, this should be the same
    /// every time the type is created.
    fn id(&self) -> &Id;

    /// Render a view of the CompositeWidget based on the current state.
    ///
    /// # Usage
    ///
    /// This method guaranteed to be called only once for the lifetime of
    /// the widget. Any state which needs to be preserved between calls to
    /// view should be persisted in the Self::State type.
    fn view(
        &mut self,
        state: &Self::State,
    ) -> Element<ComposedMessage<IMessage, EMessage>>;

    /// Update this widget's internal state based on an internal event
    /// generated by the view.
    fn update(&self, state: &mut Self::State, event: IMessage) -> Result<()>;
}

/// This type wraps any type which implements CompositeWidget to act like a
/// single Widget.
pub struct Composite<IMessage, EMessage, CW>
where
    CW: CompositeWidget<IMessage, EMessage>,
{
    composite: CW,
    current_view: Option<Element<ComposedMessage<IMessage, EMessage>>>,
}

impl<IMessage, EMessage, CW> Composite<IMessage, EMessage, CW>
where
    CW: CompositeWidget<IMessage, EMessage>,
{
    /// Create a new instance with the given CompositeWidget.
    pub fn new(composite: CW) -> Self {
        Self {
            composite,
            current_view: None,
        }
    }
}

impl<IMsg, EMsg, CW> AutoElement for Composite<IMsg, EMsg, CW> where
    CW: CompositeWidget<IMsg, EMsg>
{
}

impl<IMessage, EMessage, CW> Widget<EMessage>
    for Composite<IMessage, EMessage, CW>
where
    CW: CompositeWidget<IMessage, EMessage>,
    CW::State: 'static + Default,
{
    /// Handle events by passing them off to the widgets generated by a call
    /// to [CompositeWidget::view].
    ///
    /// Internal events trigger a call to the composite widget's update method.
    /// External events are bubbled out.
    fn handle_event(
        &mut self,
        internal_state: &mut InternalState,
        input: &Input,
        event: &glfw::WindowEvent,
    ) -> Result<Option<EMessage>> {
        if self.current_view.is_none() {
            let current_state =
                internal_state.get_state::<CW::State>(self.composite.id());
            self.current_view = Some(self.composite.view(current_state));
        }
        let result = self.current_view.as_mut().unwrap().handle_event(
            internal_state,
            input,
            event,
        )?;
        match result {
            Some(ComposedMessage::Internal(internal)) => {
                let state = internal_state
                    .get_state_mut::<CW::State>(self.composite.id());
                self.composite.update(state, internal)?;
                Ok(None)
            }
            Some(ComposedMessage::External(ext)) => Ok(Some(ext)),
            None => Ok(None),
        }
    }

    fn draw_frame(
        &self,
        internal_state: &mut InternalState,
        frame: &mut Frame,
    ) -> Result<()> {
        self.current_view
            .as_ref()
            .unwrap()
            .draw_frame(internal_state, frame)
    }

    fn dimensions(
        &mut self,
        internal_state: &mut InternalState,
        max_size: &Dimensions,
    ) -> Dimensions {
        if self.current_view.is_none() {
            let current_state =
                internal_state.get_state::<CW::State>(self.composite.id());
            self.current_view = Some(self.composite.view(current_state));
        }
        self.current_view
            .as_mut()
            .unwrap()
            .dimensions(internal_state, max_size)
    }

    fn set_top_left_position(
        &mut self,
        internal_state: &mut InternalState,
        position: Vec2,
    ) {
        if self.current_view.is_none() {
            let current_state =
                internal_state.get_state::<CW::State>(self.composite.id());
            self.current_view = Some(self.composite.view(current_state));
        }
        self.current_view
            .as_mut()
            .unwrap()
            .set_top_left_position(internal_state, position);
    }
}
